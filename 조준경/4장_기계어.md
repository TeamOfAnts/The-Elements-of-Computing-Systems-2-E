## ✅ 새롭게 알게 된 내용

## 1. 기계어

### 하드웨어 요소

> 기계어는 프로세서와 레지스터들로 메모리를 조작하도록 설계된 언어이다.

**메모리**

- 메모리는 컴퓨터에서 데이터와 명령어를 저장하는 하드웨어 장치를 통칭하는 용어이다.
- **기능 관점에서는, 고유한 주소를 가지며, 위치 또는 메모리-레지스터로도 참조될 수 있는 셀들의 연손적인 배열이라고 할 수 있다.**

**프로세서**

- 프로세서는 보통 CPU라고 불리며, 특정한 기초 연산들을 수행하는 장치이다.
- 이 연산에는 산술 및 논리 연산, 메모리 접근 연산, 제어 연산이 포함된다.
- 프로세서는 선택한 레지스터나 메모리 위치로부터 입력을 가져와,
  역시 선택된 레지스터나 메모리 위치에 출력을 기록한다.
- **프로세서는 2진 명령어를 파싱하고 실행할 수 있는 게이트 논리, ALU, 레지스터 모음으로 구성된다.**

**레지스터**

- 프로세서와 메모리는 독립적인 두개의 칩으로 구현되며,
  두 칩 사이에 데이터를 옮기는건 상대적으로 느린 작업이다.
- 이런 이유로 프로세서는 보통 값 하나를 저장할 수 있는 레지스터를 여러 개 장착하고 있다.
- 이 레지스터들은 프로세서 칩 내부에 위치하며,
  프로세서가 데이터와 명령어를 빠르게 조작할 수 있도록 로컬 고속 메모리 역할을 한다
- CPU 내에 위치한 레지스터들은 두가지 종류로 나뉜다.
  - 하나는 데이터를 저장하는 **데이터 레지스터**이고,
  - 하나는 데이터 값이나 메모리 주소로 해석되는 값들을 저장하는 **주소 레지스터**이다.
- 컴퓨터 아키텍쳐는 주소 레지스터에 특정 값 n을 설정할 경우
  주소가 n인 메모리 위치가 즉시 선택되도록 구성된다.
  그리고 선택된 메모리 위치에서 후속 연산을 수행할 준비를 한다.

### 언어

> 기계어는 하드웨어를 직접 제어하는 가장 낮은 수준의 언어로, CPU가 명령을 처리할 때 사용하는 2진수 코드로 구성된다.

기계어 프로그램은 2진(binary)와 기호(symbolic)의 두 가지 버전으로 동일하게 작성이 가능하다.

```
“R1+R2 의 값을 R1에 설정하라”
- 덧셈 연산 : 101011(6비트)
- 레지스터 R1 , R2 : 00001, 00010
- 왼쪽에서 오른쪽으로 조합(assemble) : 1010110000100010(16비트의 2진 코드로 정의)
- 기호로 표시 : R1 + R2 // 다음과 같은 기호 명령어는 어떻게 나오게 되었을까?
```

- 과거 : 2진 코드를 수동으로 입력
- 문제점 : 작업이 오래걸리고 디버깅이 쉽지 않음
  - 컴퓨터에 입력하기 전에 기록하고 디버깅하기 좋은 방법이 없을까?
  - 기호 코드를 발명
    - `101011` → `+`
    - `00001`, `00010` → `R1`, `R2`
- 발전 : 기호 명령어로 프로그램을 작성하고, 그 기호 명령어를 실행 가능한 2진 코드로 번역하는 번역키 프로그램을 사용하면 어떨까?
  - 기호 기계어 **어셈블리어**와, 그 언어를 2진 코드로 번역하는 **어셈블러** 라는 프로그램의 등장.
  - 어셈블리어 문법은 대상 하드웨어 저수준 특성과 밀접한 관련
  - 저수준 특성은 컴퓨터 마다 다양하므로 기계어 마다 마다 문법이 다양함
    - 하지만, 기계어는 다양하더라도 이론적으로 모두 같고, 하는 작업이 비슷함

### 명령어

- 모든 기계어는 기본적인 산술연산과, `And`, `Or`, `Not` 같은 논리연산들을 위한 명령어들을 지원한다.
- 기계어에서 수행되는 많은 작업들은 특정메모리에 접근하여 메모리를 조작하는 것과 관련이 있다.
- CPU는 메모리에 올라가있는 명령들을 순서대로 실행하지만, 특정 명령어로 점프하거나, 반복해야하는 경우도 있다. 기계어는 이러한 분기동작을 위한 기능도 존재한다.
  - ex: `goto` 명령어

---

### 2. 핵 기계어
- 저수준 코드를 작성하는 프로그래머는 컴퓨터의 기계어인
  `interface` 를 통해 추상적으로 대상 컴퓨터를 다룬다.
- 아래는, 저수준 프로그램에서 사용할 수 있는 하드웨어 요소들에 대한 내용과 핵 컴퓨터에 대한 개념적 사실을 작성하였다.

### 배경
핵 컴퓨터는 폰 노이만 구조라는 일반적인 16 비트의 컴퓨터 설계를 따른다.

(이 말은 곧 CPU와 메모리 장치가 16bit값들을 처리하고 저장하도록 설계되었다는 뜻이다.)

![image](https://github.com/user-attachments/assets/e9918950-3d3a-42a7-b5ee-99cb747814a8)


**메모리**

- 핵 플랫폼은 **데이터 메모리**와 **명령어 메모리**라는 두 개의 개별 메모리를 활용한다.
- 두 메모리는 모두 폭이 16비트이고, 각각 주소공간은 15비트이다.
- 따라서 각 메모리에서 주소 지정 가능한 최대 크기는 `2^15(32K)` 16비트 단어에 해당한다.
- 각 메모리 단위는 주소가 0부터 `2^15 − 1` 까지 주소 지정 가능한 메모리 레지스터가 일렬로 나열되어 있는 상태이다.

**데이터 메모리(RAM)**

- 데이터 메모리는 프로그램이 조작하는 2진 값을 저장한다.
- **읽고 쓰기**가 가능한 장치다.
- 핵 명령어는 선택된 RAM 레지스터에서 데이터를 읽거나 쓰도록 명령할 수 있다.
- 특정 레지스터는 주소를 통해 선택할 수 있다.
- 메모리의 address 입력에는 항상 어떤 값이 들어가기 때문에, 하나의 레지스터가 늘 선택되며, 그 레지스터는 핵 명령어에서 M으로 참조된다.

**명령어 메모리(ROM)**

- 명령어 메모리는 2진 값으로 표현되는 프로그램의 명령어들을 저장한다.
- 명령어 메모리는 **읽기 전용 장치**로, 프로그램은 어떤 외부 수단으로 메모리에 로드된다.
- RAM과 마찬가지로 명령어 메모리의 address 입력에는 항상 어떤 값이 들어가기 때문에, 하나의 레지스터가 늘 선택되며,이 레지스터의 값이 참조하는 것이 현재 명령어이다.

**레지스터**

> 핵 명령어는 3개의 16비트 레지스터,즉 데이터 레지스터(D), 주소 레지스터(A), 선택된 메모리 레지스터(M)을 조작하도록 설계되어 있다.

- 데이터 레지스터(D) : 16비트 값 저장
- 주소 레지스터(A) : 주소 레지스터 혹은 데이터 레지스터

- 핵 명령어를 통한 주소지정 예시
  - 값 17을 레지스터 A에 저장
  - `@17` 명령어 사용.
  - 이 명령어는 핵 컴퓨터에서 상수를 얻는 유일한 방법이다.

**주소지정 방식**

> 위 처럼 핵 명령어 @xxx 는 A 레지스터에 값 x를 설정한다.
> 또한 @xxx 명령어는 추가적인 기능이 두가지 있다.

1. 주소가 xxx인 RAM 레지스터를, '선택된 메모리 레지스터' M으로 만든다.
2. 주소가 xxx인 ROM의 레지스터의 값을 '선택된 명령어'가 되게 한다.

- 즉 A에 어떤 값을 설정하면 메모리 레지스터(M)을 조작하거나, 명령을 수행한다.
- 어떤 작업을 할지는 다음에 이어지는 핵 명령어로 결정된다.
- 메모리 접근 예제 코드

  ```assembly
  // RAM[100] = 17
  017
  D=A
  0100
  M=D

  // RAM [100] = RAM (200]
  @200
  D=M
  0100
  M=D
  ```

  - RAM[100]의 값을 17로 설정해보자.

    - 이 과정은 @17, D=A, @100, M=D 라는 명령어들로 수행할 수 있다.

  - RAM[100]의 값을 RAM[200]의 값으로 설정해보자.

    - 이 과정은 @100, D=M, @200, M=D 라는 명령어들로 수행할 수 있다.

  - 위 두 경우 모두 A 레지스터는 ROM에서도 레지스터를 선택했지만 결국 무시했다.

**분기**

> 지금까지 기본적인 제어 흐름은 순차 실행이지만,
> 핵 언어에서는 다음 명령어로 통해 분기 작업을 변경해서 수행할 수 있다. 예시로 다음 명령어 대신 29번 명령어로 분기해서 실행하려면 어떻게 해야할까?

- 이 분기 작업을 `@29`, `0;JMP` 라는 명령어들로 수행할 수 있다.
  앞에서 명령어는 ROM[29] 레지스터를 선택한다.
- 그리고 무조건 분기 명령어인 `0;JMP` 로 A 레지스터가 지정하는 주소의 명령어로 이동하고 실행하도록 할 수 있다.
- 핵 언어에는 무조건 분기 기능도 있다.
  - 예를 들어 `if D==0`, `goto 52` -> `@52`, `D;JEQ` 라는 명령어로 수행할 수 있다.
  - `D;JEQ` : D의 값을 조사하고 0과 같으면 A가 지정한 주소로 점프해 실행하라는 의미이다.
- 분기 예제 코드

  ```assembly
  //goto 29
  @29
  0;JMP

  //if D==0 goto64
  @63
  D;JGT
  ```

**변수**

- 핵 명령어 `@xxx`에서 `xxx`는 상수나 기호 모두 가능하다.

  - 명령어가 `@23`이라면 A 레지스터는 값 23으로 설정된다.
  - 명령어가 `@x`이고, `x`가 513 같은 특정 값에 바인딩 되어있다면,
    A레지스터는 513으로 설정된다.

- 기호를 활용함으로서 물리적 메모리 주소 대신 변수를 다룰 수 있게 된다.

  - 예를 들어 `let x= 17` 같이 일반적으로 고수준 언어에서 쓰이는 할당문은
    핵 언어에서 `@17`, `D=A`, `@x`, `M=D` 로 표현할 수 있다.
  - 이 코드의 의미는, 주소가 x에 바인딩 된 값인 RAM 레지스터를 선택하고,
    그 레지스터에 17을 설정하라는 의미이다.

- 여기서 x 같이 고수준 언어에서 찾아 볼 수 있는 기호들을, 데이터 메모리 주소에 바인딩하는 프로그램이 필요하다. 이 프로그램이 **어셈블러** 이다.

- 변수 사용 예제 코드

  ```assembly
  // x=-1
  @x
  M=-1


  // count = count-1
  @count
  M=M-1

  // sum = sum + x
  @x
  D=M
  @sum
  M=M+D
  ```

### 핵 언어 명세

핵 기계어는 기본적인 **A-명령어**와 **C-명령어**로 구성되며, 메모리와 레지스터를 조작하여 연산을 수행한다.

**A-명령어(주소 명령어)**

> 기호: @xxx

> 2진 버전 : 0vvvvvvvvvvvvvvv

- A-명령어는 A 레지스터에 15비트 값을 설정한다.
- 2진 버전 명령어는 필드가 두개 있다.

  - 하나는 연산 코드 (op-code)로, 가장 왼쪽 비트 0.
  - 그 뒤로 음수가 아닌 2진수를 가리키는 15개의 비트가 붙어있는 형태이다.

- A-명령어가 사용되는 목적은 세가지이다.

  1. 컴퓨터에 상수를 입력하는 유일한 수단
  2. A-명령어는 선택된 RAM 레지스터의 주소(M으로 참조됨)를 A에 설정함으로서,
     다음 C-명령어가 해당 레지스터를 조작할 수 있게 해준다.
  3. A에 점프 목적지 주소를 설정함으로써 다음 C-명령어가 점프를 할 수 있도록 준비한다.

**C-명령어(계산 명령어)**

> 기호: dest=comp; jump

> 2진 버전: 111accccccdddjjj (comp는 필수)

- C-명령어는 A-명령어와 함께 컴퓨터에서 가능한 모든 연산을 지정한다.
- C-명령어는 다음 세가지 질문에 답을 한다.
  1. 무엇을 계산할지(comp로 표시되는 ALU 연산)
  2. 어디에 계산된 값을 저장할지(dest)
  3. 다음에 무엇을 할지(jump)
- 2진 버전 명령어 필드에 대한 설명은 다음과 같다.

  - 2진 버전에서 맨 왼쪽 코드는 op-code인 1이다. (다음 두 비트는 사용되지 않으며, 관례상 1)
  - 그 다음 비트 7개는 comp 필드의 2진 표현이다.
  - 그 뒤 비트는 dest 필드의 2진 표현이다.
  - 마지막 맨 오른쪽 비트 3개는 jump 필드의 2진 표현이다.

- C-명령어 필드 상세 설명

  **1. comp (acccccc) 필드**

  > 7비트로 이루어진 comp 필드는 ALU(산술 논리 연산 장치)가 수행할 연산을 결정한다.

  - 첫 번째 ALU 입력: D 레지스터에서 받는다.
  - 두 번째 ALU 입력:

  - `a` 비트가 `0`일 때 → A 레지스터에서 입력
  - `a` 비트가 `1`일 때 → M 레지스터(즉, RAM[A])에서 입력

  - a 비트 값에 따라 수행하는 연산이 다르다.

  **2. dest (ddd) 필드**

  > 3비트로 구성된 dest 필드는 연산 결과를 저장할 목적지를 결정한다.

  - 저장하지 않음 (null)
  - RAM[A] (M 레지스터)에 저장
  - D 레지스터에 저장
  - A 레지스터에 저장
  - 여러 개의 레지스터에 동시에 저장 가능 (예: A와 D 모두 저장)

  **3. jump (jjj) 필드**

  > 3비트로 이루어진 **jump 필드**는 연산 결과에 따라 **점프할지 여부를 결정**한다.

  - `000` → 점프 없이 다음 명령어 실행
  - `001` → 연산 결과가 **0보다 크면** 점프
  - `010` → 연산 결과가 **0과 같으면** 점프
  - `100` → 연산 결과가 **0보다 작으면** 점프
  - `111` → **무조건 점프** (JMP, 관례상 `0;JMP`로 정의됨)

**A 레지스터를 사용할 때 충돌 방지 필요**

- 핵 컴퓨터는 RAM과 ROM의 주소를 지정할 때 주소 레지스터 하나만 사용한다.
- 따라서 `@n` 명령어를 실행할 때 RAM[n], ROM[n]이 둘 다 선택된다.
- 그래서 다음에 이어지는 C-명령어가 M을 조작하거나, 점프를 수행하게 된다.
- 이때 충돌을 피하기 위해서는 다음과 같이 설계해야 한다.
  **M에 대한 참고를 포함하는 C-명령어에서는 점프를 지정하지 않도록 하고, 점프를 지정한 C-명령어에서는 M을 참조하지 말아야 한다.**

---

## ✅ 어려웠거나 궁금했던 점

핵 기계어의 각 명령어의 특징과 쓰임을 이해하는 것이 어려웠다.

이 때문에 "A 레지스터가 RAM과 ROM을 동시에 참조할 수 있기 때문에 발생할 수 있는 문제로 인해 M 조작과 점프를 주의해야한다(91p. 참고)" 가 왜 문제가 되는것인지에 대해 이해가 어려워, 다음과 같이 주요 특성을 찾아 다시 한번 정리하고, 예시를 들어 문제될 수 있는 부분을 정리해보았다.

**[ 핵 컴퓨터의 A 레지스터 특성 ]**

1. **A-명령어(`@xxx`)를 실행하면 A 레지스터에 `xxx` 값이 설정됨.**

   - `@100` → A 레지스터에 `100` 저장
   - A 레지스터 : 주소 레지스터

2. **A 레지스터는 두 가지 용도로 사용됨.**
   - `RAM[100]`을 가리킬 수도 있고, (`M`으로 참조한다.)
   - `ROM[100]` (명령어 메모리)로 점프할 수도 있음.

**[ A-명령어와 C-명령어의 관계 ]**

- A-명령어(@xxx)는 단순히 A 레지스터에 값을 설정하는 명령어.
  - 예를 들어, `@100`은 A 레지스터에 100을 설정하는 명령어.
- C-명령어(dest=comp;jump)는 계산 및 메모리 작업을 수행하는 명령어.
  - `M`은 C-명령어의 `comp` 필드에서 사용.
  - 예를 들어, `D=M`은 `RAM[100]`에서 값을 읽어 D 레지스터에 저장.
  - D 레지스터 : 16 비트의 값을 저장하는 데이터 레지스터

**[문제 발생 가능성]**

C-명령어(`dest=comp;jump`)에서 **점프(jump)와 M(메모리 참조)를 동시에 사용하면 문제가 생김.**

예를 들어, 다음 코드는 정상적으로 동작한다.

```assembly
@100
D=M     // RAM[100]의 값을 D에 저장
@200
0;JMP   // ROM[200]으로 점프
```

- `@100` → A 레지스터에 100 저장 (RAM[100]이 선택됨)
- `D=M` → RAM[100] 값을 D에 저장
- `@200` → A 레지스터에 200 저장 (ROM[200]이 선택됨)
- `0;JMP` → ROM[200]의 명령어로 점프

그러나 문제 발생 가능성 예시대로, 아래처럼 **점프 명령과 메모리 참조(`M` 사용)를 동시에 포함하면 문제가 된다.**

```assembly
@100
D=M     // RAM[100]의 값을 D에 저장
D;JGT   // 만약 D가 양수면 점프
```

- 여기서 `D;JGT` 실행 시 **A 레지스터 값은 여전히 100**이다.

- 그러면 **점프할 주소가 ROM[100]인지, RAM[100]을 가리키는지 모호해짐.**

이러한 이유 때문에 충돌을 방지하려면

1. **점프가 있는 C-명령어(`D;JGT`, `0;JMP` 등)에서는 `M`을 사용하지 않는다.**
2. **`M`을 참조하는 C-명령어(`D=M` 등)에서는 점프 명령을 포함하지 않는다.**

최종적으로 A 레지스터를 사용할 때 충돌 방지를 위해서는, 다음 사항을 주의하도록 한다.

**✅ 점프 명령을 사용할 때는 RAM을 참조하지 말자.**

**✅ RAM을 참조할 때는 점프 명령을 사용하지 말자.**
