
어셈블러를 통해 명령줄 인수 처리, 입력 및 출력 테스트 파일 처리, 명령어 파싱, 공백 처리, 기호 처리, 2진 코드 생성 등을 처리한다.


### 1. 새롭게 알게 된 내용 

* 어셈블러 역할
	* 어셈블리어 -> 기계어로 번역
	 *기계어는 기호 또는 2진 형식으로 정의
* 어셈블러의 주요 기능
	* '**기호 테이블**'을 사용해서 사용자 정의 기호를 관리하고 물리적 주소에 할당
* 어셈블러 제작의 핵심 단계
	* 구문 분석(Parsing)
		* 각 줄의 명령을 읽고 A-명령, C-명령, L-명령(레이블) 구분
	* 기호 처리(Symbol Handling)
		* @i, (LOOP) 같은 변수나 레이블을 메모리 주소로 변환
	* 이진 코드 변환
		* 명령어를 각각 16비트 기계어 코드로 변환
* 어셈블러는 어셈블리(연상 기호(mnemonic)) 명령어의 필드를 분석해서 동일한 의미의 2진 코드로 바꾸고, 그 코드들을 실제로 하드웨어에서 실행 가능한 2진 명령어로 조립(assemble)
* 어셈블리어가 기호를 사용하는 이유
	* 레이블(label): 코드 내 위치를 표시하기 위해 기호를 정의하고 사용, 아무런 코드도 생성하지 않음(예: )
	* 변수(variable): 기호 변수를 정의하고 사용
	* 선언 기호(predefined symbol): 미리 선언된 기호를 사용해 컴퓨터 메모리 내의 특정 주소 참조 가능
	* 각 명령어의 줄 번호는 메모리 주소와 일치
* 어셈블러의 구성
	* Parser
		* 어셈블리 코드를 한줄씩 읽고 그 명령이 어떤 의미인지 해석해주는 모듈
		* 현재 명령어가 A-명령, C-명령, L-명령 구분 등
		* comp, dest, jump 부분 분리해서 제공
	* Code
		* Parser로부터 받은 comp, dest, jump 등의 정보를 2진 코드로 변환해주는 모듈
	* Symbol Table
		* 변수나 레이블을 메모리 주소에 매핑하는 테이블
		* LOOP 같은 레이블을 명령어 주소로 등록
		* @i 같은 변수를 사용하면, RAM 16번부터 자동으로 주소 할당
		* R0~R15, SCREEN, KBD 등은 초기부터 등록된 심볼

[ASM 파일]  
↓ (1차 순회)  
Parser → SymbolTable ← 레이블 등록  

↓ (2차 순회)  
Parser → Code → 기계어로 변환  
        ↑  
   SymbolTable: 변수, 레이블 주소 해석
