### ✅ **DFF에서 D(t-1) 값은 어디서 가져오는가?**

DFF가 **이전 입력값 D(t−1)D(t-1)D(t−1)** 을 따로 저장하는 것은 아니야.  
대신, 클럭 엣지가 발생하기 전까지 **출력 QQQ 는 기존 상태를 유지**하고 있어.  
즉, **출력되는 값은 항상 한 클럭 전의 입력값이 저장된 상태(Q)에서 나온다**는 의미야.

---

## 🔹 **DFF의 상태 업데이트 과정 (시간 흐름)**

### **📌 1️⃣ 클럭 엣지 발생 전 (기존 상태 유지)**

- 클럭이 변경되기 **직전까지**는, DFF의 내부 상태 QQQ 가 그대로 유지됨.
- 따라서, 현재 출력 QQQ 는 이전 클럭 엣지에서 저장된 값 Q(t−1)Q(t-1)Q(t−1) 을 계속 출력하고 있음.

### **📌 2️⃣ 클럭 엣지에서 (새로운 입력 저장)**

- 클럭 엣지가 발생하면, **현재 입력 D(t)D(t)D(t) 값을 내부 상태 QQQ 에 저장.**
- 즉, Q(t)Q(t)Q(t) 가 업데이트되면서, 다음 클럭 사이클까지 유지됨.

### **📌 3️⃣ 클럭 엣지 후 (출력 유지)**

- 클럭이 변하고 나면, 새로운 상태 Q(t)Q(t)Q(t) 가 현재 출력으로 유지됨.
- 이제, D(t)D(t)D(t) 값은 다음 클럭 사이클까지 반영되지 않음.

---

## 🔹 **DFF가 D(t-1) 값을 기억하는 것처럼 보이는 이유**

📌 **핵심 개념**

- **DFF는 이전 상태(Q)를 유지하는 특성이 있기 때문에, 현재 출력(Q)은 한 클럭 전의 입력값(D)이 반영된 것처럼 보이는 것.**
- 하지만, 실제로 D(t−1)D(t-1)D(t−1) 자체를 따로 저장하는 게 아니라, **출력(Q)이 유지되는 특성 덕분에** 한 클럭 전 값이 남아있는 것처럼 보임.

![](./asset/시간흐름정리.png)

📌 **정리하면?**

- **출력(Q)는 현재 상태값을 그대로 유지하기 때문에, 한 클럭 전의 입력값이 반영된 것처럼 보임.**
- 하지만 실제로 DFF는 과거 데이터를 저장하는 게 아니라, **출력을 유지하는 특성 덕분에 논리적으로 한 사이클 전의 값을 기억하는 것처럼 보이는 것.**

---

## 🔹 **결론**

✅ **DFF는 실제로 D(t-1)을 저장하지 않음.**  
✅ **대신, 현재 상태(Q)가 유지되면서, 한 클럭 전의 데이터가 출력되는 효과가 발생.**  
✅ **클럭 엣지가 발생하기 전까지, 기존 출력(Q)이 유지되므로 한 클럭 전의 데이터가 남아 있는 것처럼 보임.**

즉, **"DFF는 클럭 엣지가 발생하기 전까지 기존 상태를 유지하기 때문에, 논리적으로 한 클럭 전의 데이터를 기억하는 것처럼 보이는 것"**이야! 🚀