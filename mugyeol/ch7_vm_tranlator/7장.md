

고수준 언어 -> vm 코드 -> 어젬블리어 -> 2비트 기계어 

7장에서 만들건 vm 번역기! (가상머신 만들기, vm 구현) 



## VM 방식이 인기 있는 이유 
1단계 컴파일 모델 
: 고수준 언어 -> 어젬블리어 
=> 이식성이 낮다 
각 나라 언어로 직접 번역 → 나라 바뀔 때마다 다시 번역

2단계 컴파일 모델
: 고수준 언어 -> vm 코드(중간 코드) -> 어젬블리어 
=> 이식성이 높다  
공통 언어(예: 영어)로 번역 → 각 나라에서 영어를 알아듣는 해석기만 있으면 됨


- C: 플랫폼마다 컴파일 필요 → 리눅스용, 윈도우용 따로 빌드

- Java: 바이트코드 한 번 만들면 됨 → JVM만 깔려 있으면 실행됨

## VM 방식이 아니더라도 고수준 언어는 중간 언어 단계를 거침 
p163. "컴파일러 개발자들이 중간 인터페이스 개념을 발전시키다가 이 인터페이스가 어떤 추상화된 기계의 독립적인 언어로 정의해도 될 만큼 중요하다는 결론에 도달. 그 추상화된 기계가 바로 가상 머신" 


✅ 고수준 → 기계어 컴파일 과정

파싱 (Parsing)
고수준 언어 → 추상 구문 트리(AST)로 분석
→ 문법 구조 파악

중간 표현 (IR: Intermediate Representation)
→ 여기가 가상의 중간 코드 (≒ VM 코드)
→ 기계 독립적이고 최적화하기 쉬운 형태
→ 예: LLVM IR, Three-Address Code, SSA 등

타겟 코드 생성 (Target Code Generation)
→ IR을 실제 플랫폼의 어셈블리/기계어로 변환

## 스택 머신
p165. 
- "VM 언어 설계가 효과적이려면 고수준 언어의 편리함과 저수준 기계어의 다양성 사이에 균형을 잡아야 한다." 
- "충분히 고수준이면서 충분히 저수준이어야 한다. 
p166. 
- 어떤 고수준 프로그래밍 언어로 작성된 프로그램도 스택상에서 이뤄지는 순차적인 연산들로 번역이 가능하다는 사실만 알고 있으면 된다. 
- 결과적으로 이 동작 논리는 프로그램 번역과 실행의 목적에 딱 맞지만, 두 개 장을 다 읽어야 왜 그런지 알 수 있을 것이다. 

스택
- 읽기 : 손실, 쓰기 : 무손실 
(메모리는, 읽기 : 무손실, 쓰기 : 손실) 


push : segment[index] 를 스택에 push, sp++
pop : 최상단 스택을 poop 해서 segment[index]에 저장. sp -- 

산술 - 논리 명령
- 산술 : add, sub, neg, 
- 비교 : eg, gt, lt
- 논리 : and, or not 
: not, neg제외하고는 암묵적으로 두개의 피연산자 pop -> 연산 -> push 

push x = RAM[sp++] = x // RAM[SP] = x 하고 SP ++ 해야되는거 아닌가 ? 
(pop도 마찬가지로, 173p 하단 설명 헷갈리는 부분)

## VM 표준 매핑
- 특정 하드웨어 플랫폼에 VM 추상화 구현하기 위해서는 보통 VM 설계자들은 다양한 하드웨어 플랫폼에서 VM 구현을 위해 표준 매핑이라는 기본 구현 가이드라인을 제공한다. 

- VM 프로그램 (파일명 컨벤션)
- 데이터 타입 (부호 있는 정수)
- RAM 활용 (참고 - 핵 기계어 명세 : SP, LCL, ARG, THIS, THAT)
- pointer 0 : THIS, pointer 1 : THAT

## VMTranslator 프로그램 구조 
- Parser 모듈 : .vm 파일 파싱 
- CodeWriter 모듈 : 파싱된 vm 명령을 어젬블리어로 번역

