# 기계어
- 이 컴퓨터의 목적 : 기계어의 실행 
- 시스템에서 가장 기본이 되는 인터페이스. 
    - 고수준 프로그램으로 표현된 사람의 추상적 아이디어가 물리적 연산으로 바뀌는 지점. 

## 4.1. 기계어 : 개요
### 4.1.1. 하드웨어 요소
- "기계어는 프로세서와 레지스터들로 메모리를 조작하도록 설계된 언어로 볼 수 있다"

#### 메모리
- 데이터와 명령어를 저장하는 하드웨어 장치들을 통칭. (dff, 레지스터, ram, counter)
- 기능적으로 고유한 주소를 가지며, 위치 또는 메모리 레지스터로도 참조될 수 있는 셀들의 연속적인 배열. 

#### 프로세서 (CPU)
- 특정한 기초 연산들을 수행하는 장치. 
    - 산술 및 논리 연산
    - 메모리 접근 연산
    - 제어(분기) 연산
- 선택한 레지스터나 메모리 위치에서 입력을 가져온다. 
- 선택된 레지스터나 메모리 위치에 출력을 기록한다. 
- 게이트 논리, ALU, 레지스터 모음으로 구성된다. 

#### 프로세서 내장 레지스터
- 프로세서와 메모리는 독립적인 두 개의 칩으로 구현되어 있음 
    - 두 칩 사이에 데이터를 옮기는 건 상대적으로 느린 작업이다.
    -> (값 하나를 저장할 수 있는) 레지스터를 프로세서 내에 여러개 장착하는 이유 
- CPU 내의 레지스터들은 두 가지 종류로 나뉜다. 
    1. 데이터 레지스터
    2. 주소 레지스터 

    ‼️️"컴퓨터 아키텍처는 주소 레지스터에 특정값 1을 설정할경우 주소가 n인 메모리 위치가 즉시 선택되도록 구성된다. 그리고 선택된 메모리 위치에서 후속연산을 수행할 준비를 한다."


### 4.1.2. 언어 (어젬블리어)
- "R1 + R2의 값을 R1에 설정하라"
    - 101011 -> 덧셈 연산
    - 00001 -> R1
    - 00010 -> R2

- 명령어 (2진 코드) : 1010110000100010
    - 초창기 : 기계식 스위치 16번 껏다 / 켰다로 입력 

- 기호 코드 발명 (add R2, R1)
- 기호 기계어 : **어젬블리어** 
- 기호 기계어를 2진 코드로 번역 하는 프로그램 : **어젬블러**

- 고수준 언어 문법과 달리 어젬블리어 문법은 하드웨어에 독립적이지 않다. 
    - 특정 CPU 군에 특화된 기계어들이 있고, 서로 문법이 통하지 않는다. 
    - 이론적으로는 모두 같다. 


### 4.1.3. 명령어
#### 산술 및 논리 연산 
![](<./asset/산술_및_논리연산.png>)
- 💡이러한 기호 명령어를 실행하려면 2진코드로 번역해야 한다. 
        - 번역은 어젬블러가 수행하며, 6장에서 개발할 예정이다. 

#### 메모리 접근

❓️️"메모리 접근 기계어에서 수행되는 작업들은 전부 다 특정 메모리 위치에 접근해서 메모리를 조작하는 것과 관련이 있다. 이 작업은 보통 주소 레지스터를 통해 이뤄지는데, 이 레지스터를 A라 하자. 예를 들어, 메모리 위치 17에 값 1을 설정하려 한다고 해보자. 이 작업은 LoadA, 17과 LoadM, 1이라는 두 명령어로 지시할 수 있는데, 여기서 M은 관례상 A가 선택한 메모리 레지스터(즉, A의 현재 값이 주소인 메모리 레지스터)를 뜻한다.

이 상황에서 15개의 메모리 위치 100, 201, 202, ..., 249에 1을 설정하려 한다고 해보자. 이 작업은 LoadA, 200 명령을 실행하고 나서, LoadM, 1과 A, A, 1 명령어를 50번 반복하는 루프를 수행하면 된다."

-> (오타 수정) 15개 -> 50개, 100, 201 -> 200, 201

코드 예시 : 
![](<./asset/메모리접근_코드예시.png>)


#### ❓흐름 제어
- 조건 및 무조건 goto 분기 명령어
- 레이블 선언문 : goto의 목적지를 설정 

#### 기호 
![](<./asset/물리적_주소_기호_주소.png>)
- 물리적 주소를 쓰지 않는 저수준 코드를 재배치 가능한 코드라고 부른다. (❓두 이미지에 대한 설명이 더 필요하다..️)


## 4.2. 핵 기계어
- 하드웨어 요소들 숙지 필요 

### 4.2.1. 배경
- 폰 노이만 구조 
- 핵은 16비트 컴퓨터
    - CPU와 메모리 장치가 16비트 값들을 처리하고, 이동하고, 저장하도록 설계 되었다는것을 뜻한다. 

#### 메모리
![](<./asset/핵_메모리.png>)

- 데이터 메모리 (RAM) : 읽기 / 쓰기 장치
    - address 입력으로 선택된 레지스터는 M으로 참조된다. 
    - M=0 명령어는 선택된 RAM 레지스터에 0을 설정하라는 뜻

- 명령어 메모리 (ROM) : 읽기 전용 장치 
    - address 입력으로 선택된 레지스터가 참조하는 것이 현재 명령이다.


#### 레지스터 
- 핵 명령어는 3개의 16비트 레지스터 (D, A, M)를 조작하도록 설계되어 있다. 
- D (데이터 레지스터) : 16비트 값 저장
- A (주소 레지스터 or 데이터 레지스터 역할)
    - @17 : A레지스터에 17 저장 (상수를 얻는 유일한 방법)
    - @17 -> D=A : D레지스터에 17 설정
    - 두 번째 데이터 레지스터 역할 + 데이터 메모리, 명령어 메모리 주소 지정에 활용됨
- M (선택된 데이터, 명령어 메모리 레지스터) -> ❓뒷 내용을 보면 명령어 메모리 레지스터도 선택되는 것으로 보인다. 

#### 주소 지정
- @xxx의 기능 
    - 기본 : A레지스터에 값 xxx설정
    - 추가 기능
        1. 주소가 xxx인 RAM 레지스터를, '선택된 메모리 레지스터' M으로 만든다.
        2. 주소가 xxx인 ROM 레지스터의 값을 '선택된 명령어'가 되게 한다. 
    - 따라서 A에 어떤 값을 설정하는 것은, 그와 동시에 매우 다른 두 가지 후속 작업을 준비하는 것과 같다. 
        - 그 후속 작업이란, 선택된 데이터 메모리 레지스터를 조작하거나, 선택된 명령어로 무언가를 하는 것
        - 어떤 작업을 할지(또는 안하게 될지)는 다음에 이어지는 핵 명령어로 결정된다. 

- 예시1. RAM[100] 의 값을 17로 설정
    - @17, D=A, @100, M=D
- 예시2. RAM[100]을 RAM[200]의 값으로 설정
    - @200, D=M, @100, M=D

    => 두 예시 모두 명령어 메모리 레지스터도 선택했지만 무시하고 있음. 
    => @xxx 명령 : 하나의 주소 레지스터로 두 개의 별도 메모리 장치를 제어


#### 분기 
- 다음 명령 실행(순차 실행) 대신 29번 명령어로 분기해서 실행하려면 ?
    무조건 분기
    - @29, 0;JMP => goto 29
    - 0;JMP : A레지스터가 지정하는 주소의 명령어로 이동해서 실행하라
    조건부 분기
    - @52, D;JEQ => if D==0 goto 52
    - D;JEQ : D를 평가하라; 그 값이 0과 같으면, A가 지정한 주소에 저장된 명령어로 점프해서 실행하라.    
    - 이런 조건부 분기 명령이 몇가지 있는데, 장 뒷부분에서 다룰 것 
        - @63, D;JGT : if D>0 goto 63


#### 변수
- @xxx 의 xxx 는 상수, 기호 모두 가능하다. (기호는 변수)
- @17, D=A, @x, M=D => "주소가 기호 x에 바인딩 된 값인 RAM레지스터를 선택하고, 이 레지스터에 17을 설정하라"
- x 같은 기호들을 데이터 메모리의 주소에 실용적이고, 일관된 방식으로 바인딩하는 역할을 하는 프로그램이 필요
    - 그 프로그램이 바로 **어젬블러**

- 어젬블러 덕분에 할 수 있는 일
    - @30, M=M+1 카운터 코드를, 
    - @count, M=M+1 명령어로 가능 (더 효율적)
    - **어젬블러에 대한 설명(매핑 연산 구현)은 6장에서**

- 핵 어젬블리는 R0, R1, R2,..., R15까지 내장 기호 지원 (0,1,2,...,15까지 매핑)

#### 핵 어젬블리 코드 예제들 
![](<./asset/핵_어젬블리코드_예제.png>)


### 4.2.2. 프로그램 예제 
- "고수준 언어와 달리 기계어는 프로그래머를 편하게 만들어 주지 않는다. 기계어는 단지 하드웨어 플랫폼을 효율적이고 명확하게 제어할 수 있도록 설계된 언어다."

- 1+2+3+...+n 덧셈 계산 (RAM[0] = n, RAM[1] = 덧셈 출력)
![](<./asset/핵_어젬블리_프로그램_예제.png>)
- ❓@i (어젬블러가 필요하다는 부분)에 대한 설명은 제외한듯 하다. 


### 4.2.3. 핵 언어 명세
- 핵 기계어는 그림에 정의된 두 가지 명령어로 구성된다. 
![](<./asset/핵_명령어_목록.png>)
- C-명령어에서, 
    - comp는 필수
    - dest가 비어잇으면 =는 생략
    - jump가 비어 있으면 ;는 생략

#### A-명령어 (address instruction)
- A레지스터에 15비트값 설정 (0xxxxxxxxxxxxxxx)
- (나머지 역할은 위에서 다룸)

#### C-명령어 (compute instruction)
- A-명령을 제외한 모든 명령어
- dest = comp;jump
- 2진 코드 : 111accccccdddjjj
    - 맨 왼쪽 비트 1 : c명령어의 op-code
    - 다음 두 비트 : 사용되지 않음 (관례상 1)
    - acccccc : comp 필드 
    - ddd : dest 필드
    - jjj : jump 필드


#### 계산 명세(comp)
- "핵 ALU는 주어진 2개의 16비트 입력에 대해, 정해진 함수들 중 하나를 계산하도록 설계되어 있다"
    - ❓ 명령어 목록을 보면, 입력이 하나일 수도, 하나와 상수, 논리 연산도 존재
- 첫 번째 입력 : D 
- 두 번째 입력 : A레지스터 (a비트=0) or M (a비트=1)
- D-1 (null=D-1 [jump생략]) : 1110012100000

❓ C-명령어는 ALU가 수행, A-명령어는 누가 수행 ?

#### 목적지 명세
#### 점프 지정
#### A 레지스터를 사용할 때 충돌 방략


### 4.2.4. 기호
#### 선언 기호
#### R0, R1, ..., R15
#### SP, LCL, ARG, THIS, THAT
#### Screen, KBD
#### 레이블 기호
#### 변수 기호


### 4.2.5. 입력 / 출력 처리 
#### 스크린
#### 키보드

### 4.2.6. 구문 규칙과 파일 형식 
#### 2진 코드 파일
#### 어젬블리어 파일
#### 상수와 기호 
#### 주석 -> //
#### 공백
#### 대소문자 규칙 
- 모든 어젬블리 연상 기호 : 대문자
- 레이블 기호 : 대문자
- 변수명 : 소문자 

## 4.3. 핵 프로그래밍 
#### 예제 1.
#### 예제 2.
#### 예제 3.

## 4.4. 프로젝트 
#### 목표 : 저수준 프로그래밍 맛보기 + 핵 컴퓨터 시스템에 익숙해지기 
#### 자료 : 핵 CPU 에뮬레이터(nand2tetris/tools) / 테스트 스크립트 (project/04)
#### 과제
1. 곱셈 프로그램 (mult.asm)
2. I/O 처리 프로그램 (Fill.asm)
#### CPU 에뮬레이터
![](<./asset/CPU_에뮬레이터.png>)
#### 단계 (권장 진행 순서)

## 4.5. 정리 
- 핵 기계어는 기초적이다. 
- add M,D (범용적 문법) 대신 D=D+M 처럼 친숙한 문법 사용
- 1/2 주소 기계어라고 말할 수 있다. 
    - 기계어를 구분하는 주요 특성 중 하나는 한 개의 명령어에서 사용할 수 있는 주소의 갯수다. 
    - 핵 기계어는 A-명령어와 C-명령어 두 개를 써야 온전하게 메모리 접근 연산을 표현 할 수 있기 때문에 1/2 주소 기계어라고 볼 수 있다. (핵의 16비트 명령어 하나에 명령어 코드와 15비트 주소를 동시에 쓸 공간이 없음)

